import { Client, TextChannel, EmbedBuilder } from 'discord.js';
import { exec } from 'child_process';
import util from 'util';
import fs from 'fs';
import path from 'path';
import os from 'os';

const execAsync = util.promisify(exec);

/**
 * Interface for vulnerability data
 */
interface Vulnerability {
    id: string;
    name: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    description: string;
    affected_package?: string;
    affected_version?: string;
    fix_version?: string;
    cve?: string;
    remediation?: string;
    discovered_at: Date;
}

/**
 * Interface for scan result data
 */
interface ScanResult {
    timestamp: Date;
    scanner: string;
    vulnerabilities: Vulnerability[];
    summary: {
        total: number;
        critical: number;
        high: number;
        medium: number;
        low: number;
    };
    scan_duration: number; // in seconds
    scan_target: string;
    scan_options?: string;
}

/**
 * Class for vulnerability scanning using various tools
 */
export class VulnerabilityScanner {
    private client: Client;
    private notifyChannelId: string;
    private logEvent: (type: string, description: string) => Promise<boolean>;
    private scanInterval: NodeJS.Timeout | null = null;
    private isScanning: boolean = false;
    private lastScanResult: ScanResult | null = null;
    private scanTools: Map<string, boolean> = new Map();
    private resultsDir: string;

    constructor(
        client: Client,
        notifyChannelId: string,
        logEvent: (type: string, description: string) => Promise<boolean>,
        resultsDir?: string
    ) {
        this.client = client;
        this.notifyChannelId = notifyChannelId;
        this.logEvent = logEvent;
        
        // Set up results directory
        this.resultsDir = resultsDir || path.join(process.cwd(), 'data', 'vulnerability-scans');
        if (!fs.existsSync(this.resultsDir)) {
            fs.mkdirSync(this.resultsDir, { recursive: true });
        }
    }

    /**
     * Initialize the vulnerability scanner by detecting available tools
     */
    public async initialize(): Promise<boolean> {
        try {
            console.log('Initializing vulnerability scanner...');
            
            // Check for various vulnerability scanning tools
            await this.detectScanningTools();
            
            // If no scanning tools available, we'll use simulated results
            if (this.scanTools.size === 0) {
                console.log('No vulnerability scanning tools detected. Will use simulated data.');
                this.scanTools.set('simulated', true);
            }
            
            await this.logEvent('SECURITY', `Vulnerability scanner initialized with tools: ${Array.from(this.scanTools.keys()).join(', ')}`);
            return true;
        } catch (error) {
            console.error('Error initializing vulnerability scanner:', error);
            return false;
        }
    }

    /**
     * Detect available scanning tools on the system
     */
    private async detectScanningTools(): Promise<void> {
        // Check for OpenVAS / GVM
        try {
            const { stdout: gvmCheck } = await execAsync('gvm-cli --version || openvas --version');
            if (gvmCheck) {
                console.log('GVM/OpenVAS detected:', gvmCheck.trim());
                this.scanTools.set('openvas', true);
            }
        } catch (error) {
            // OpenVAS not found
        }
        
        // Check for Nessus
        try {
            const { stdout: nessusCheck } = await execAsync('systemctl status nessusd || ps aux | grep nessusd');
            if (nessusCheck && !nessusCheck.includes('grep nessusd')) {
                console.log('Nessus service detected');
                this.scanTools.set('nessus', true);
            }
        } catch (error) {
            // Nessus not found
        }
        
        // Check for Lynis (Linux security auditing)
        try {
            const { stdout: lynisCheck } = await execAsync('lynis --version');
            if (lynisCheck) {
                console.log('Lynis detected:', lynisCheck.trim());
                this.scanTools.set('lynis', true);
            }
        } catch (error) {
            // Lynis not found
        }
        
        // Check for OVAL scanning tools (oscap)
        try {
            const { stdout: oscapCheck } = await execAsync('oscap --version');
            if (oscapCheck) {
                console.log('OpenSCAP detected:', oscapCheck.split('\n')[0]);
                this.scanTools.set('oscap', true);
            }
        } catch (error) {
            // OpenSCAP not found
        }
        
        // Check for Trivy (container security scanner)
        try {
            const { stdout: trivyCheck } = await execAsync('trivy --version');
            if (trivyCheck) {
                console.log('Trivy detected:', trivyCheck.trim());
                this.scanTools.set('trivy', true);
            }
        } catch (error) {
            // Trivy not found
        }
        
        // Check for apt security tools (Debian/Ubuntu)
        try {
            const { stdout: osCheck } = await execAsync('cat /etc/os-release');
            if (osCheck.includes('debian') || osCheck.includes('ubuntu')) {
                try {
                    await execAsync('which apt');
                    console.log('Apt detected, can use for security package scanning');
                    this.scanTools.set('apt', true);
                } catch (error) {
                    // apt not found
                }
            }
        } catch (error) {
            // Not Debian/Ubuntu
        }
        
        // Check for RHEL/CentOS tools
        try {
            const { stdout: osCheck } = await execAsync('cat /etc/os-release');
            if (osCheck.includes('rhel') || osCheck.includes('centos') || osCheck.includes('fedora')) {
                try {
                    await execAsync('which yum');
                    console.log('Yum detected, can use for security package scanning');
                    this.scanTools.set('yum', true);
                } catch (error) {
                    // yum not found
                }
            }
        } catch (error) {
            // Not RHEL/CentOS
        }
        
        console.log(`Detected ${this.scanTools.size} vulnerability scanning tools`);
    }

    /**
     * Start periodic vulnerability scanning
     */
    public startScheduledScans(intervalMs: number = 24 * 60 * 60 * 1000): void { // Default: daily
        console.log(`Starting scheduled vulnerability scans every ${intervalMs/3600000} hours`);
        
        // Cancel any existing schedule
        if (this.scanInterval) {
            clearInterval(this.scanInterval);
        }
        
        // Set up periodic scanning
        this.scanInterval = setInterval(async () => {
            // Don't start a new scan if one is already running
            if (!this.isScanning) {
                await this.runScan('scheduled');
            }
        }, intervalMs);
        
        this.logEvent('SECURITY', `Scheduled vulnerability scans set for every ${intervalMs/3600000} hours`);
    }

    /**
     * Stop scheduled vulnerability scanning
     */
    public stopScheduledScans(): void {
        if (this.scanInterval) {
            clearInterval(this.scanInterval);
            this.scanInterval = null;
            console.log('Scheduled vulnerability scans stopped');
            this.logEvent('SECURITY', 'Scheduled vulnerability scans stopped');
        }
    }

    /**
     * Run a vulnerability scan using available tools
     */
    public async runScan(
        scanType: 'manual' | 'scheduled' = 'manual',
        options: { quick?: boolean; target?: string } = {}
    ): Promise<ScanResult> {
        // Prevent multiple concurrent scans
        if (this.isScanning) {
            throw new Error('A scan is already in progress');
        }
        
        this.isScanning = true;
        
        try {
            console.log(`Starting ${scanType} vulnerability scan...`);
            await this.logEvent('SECURITY_SCAN', `Starting ${scanType} vulnerability scan`);
            
            const startTime = Date.now();
            
            let scanResult: ScanResult;
            
            // Determine which scan method to use based on available tools
            if (this.scanTools.has('openvas')) {
                scanResult = await this.runOpenVASScan(options);
            } else if (this.scanTools.has('lynis')) {
                scanResult = await this.runLynisScan();
            } else if (this.scanTools.has('oscap')) {
                scanResult = await this.runOpenSCAPScan();
            } else if (this.scanTools.has('apt')) {
                scanResult = await this.runAPTScan();
            } else if (this.scanTools.has('yum')) {
                scanResult = await this.runYumScan();
            } else if (this.scanTools.has('trivy')) {
                scanResult = await this.runTrivyScan(options.target || '');
            } else {
                // Use simulated data if no tools available
                scanResult = this.generateSimulatedScanResult();
            }
            
            // Calculate scan duration
            const endTime = Date.now();
            scanResult.scan_duration = Math.round((endTime - startTime) / 1000);
            
            // Save scan result
            this.lastScanResult = scanResult;
            
            // Save to file
            await this.saveScanResult(scanResult);
            
            // Send report to Discord
            await this.reportScanResults(scanResult, scanType);
            
            console.log(`Vulnerability scan completed in ${scanResult.scan_duration} seconds. Found ${scanResult.vulnerabilities.length} vulnerabilities.`);
            await this.logEvent('SECURITY_SCAN', 
                `Vulnerability scan completed: found ${scanResult.summary.total} vulnerabilities ` +
                `(${scanResult.summary.critical} critical, ${scanResult.summary.high} high)`);
            
            return scanResult;
        } catch (error) {
            console.error('Error during vulnerability scan:', error);
            await this.logEvent('ERROR', `Vulnerability scan failed: ${error instanceof Error ? error.message : String(error)}`);
            
            // Return an empty result on error
            return {
                timestamp: new Date(),
                scanner: 'error',
                vulnerabilities: [],
                summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
                scan_duration: 0,
                scan_target: 'error',
            };
        } finally {
            this.isScanning = false;
        }
    }

    /**
     * Run an OpenVAS/GVM vulnerability scan
     */
    private async runOpenVASScan(options: { quick?: boolean } = {}): Promise<ScanResult> {
        // This is a simplified implementation, as OpenVAS/GVM typically requires
        // a more complex setup with proper credential management, targets, etc.
        try {
            console.log('Running OpenVAS/GVM scan...');
            
            // In a real implementation, you would:
            // 1. Use the GVM CLI or API to create a target
            // 2. Create a task for scanning
            // 3. Start the task
            // 4. Poll for results
            // 5. Parse the XML or JSON results
            
            // Since this is complex, we'll simulate the results for this example
            console.log('Simulating OpenVAS/GVM scan results (actual implementation would use GVM CLI/API)');
            
            // This is where you'd parse actual XML/JSON results from OpenVAS
            // For now, we'll generate simulated results
            return {
                timestamp: new Date(),
                scanner: 'openvas',
                vulnerabilities: this.generateSimulatedVulnerabilities(options.quick ? 5 : 15),
                summary: {
                    total: options.quick ? 5 : 15,
                    critical: options.quick ? 1 : 2,
                    high: options.quick ? 1 : 4,
                    medium: options.quick ? 2 : 6,
                    low: options.quick ? 1 : 3
                },
                scan_duration: options.quick ? 120 : 600,
                scan_target: os.hostname()
            };
        } catch (error) {
            console.error('Error running OpenVAS scan:', error);
            throw error;
        }
    }

    /**
     * Run a Lynis security audit
     */
    private async runLynisScan(): Promise<ScanResult> {
        try {
            console.log('Running Lynis security audit...');
            
            // Create output directory if it doesn't exist
            const lynisOutputDir = path.join(this.resultsDir, 'lynis');
            if (!fs.existsSync(lynisOutputDir)) {
                fs.mkdirSync(lynisOutputDir, { recursive: true });
            }
            
            const reportFile = path.join(lynisOutputDir, `lynis-report-${Date.now()}.txt`);
            
            // Run Lynis audit with report output
            const { stdout } = await execAsync(`lynis audit system --report-file=${reportFile}`);
            
            // Parse Lynis results
            const vulnerabilities: Vulnerability[] = [];
            
            // Example parsing of Lynis output (simplified)
            const warnings = stdout.match(/Warning: (.*)/g) || [];
            const suggestions = stdout.match(/Suggestion: (.*)/g) || [];
            
            // Process warnings as high severity vulnerabilities
            warnings.forEach((warning, index) => {
                const match = warning.match(/Warning: (.*)/);
                if (match) {
                    vulnerabilities.push({
                        id: `LYNIS-W-${index + 1}`,
                        name: match[1],
                        severity: 'high',
                        description: match[1],
                        remediation: 'Review Lynis report for details',
                        discovered_at: new Date()
                    });
                }
            });
            
            // Process suggestions as medium severity vulnerabilities
            suggestions.forEach((suggestion, index) => {
                const match = suggestion.match(/Suggestion: (.*)/);
                if (match) {
                    vulnerabilities.push({
                        id: `LYNIS-S-${index + 1}`,
                        name: match[1],
                        severity: 'medium',
                        description: match[1],
                        remediation: 'Review Lynis report for details',
                        discovered_at: new Date()
                    });
                }
            });
            
            // Count vulnerabilities by severity
            const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
            const high = vulnerabilities.filter(v => v.severity === 'high').length;
            const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
            const low = vulnerabilities.filter(v => v.severity === 'low').length;
            
            return {
                timestamp: new Date(),
                scanner: 'lynis',
                vulnerabilities,
                summary: {
                    total: vulnerabilities.length,
                    critical,
                    high,
                    medium,
                    low
                },
                scan_duration: 180, // Estimated
                scan_target: os.hostname(),
                scan_options: 'audit system'
            };
        } catch (error) {
            console.error('Error running Lynis scan:', error);
            throw error;
        }
    }

    /**
     * Run an OpenSCAP vulnerability scan
     */
    private async runOpenSCAPScan(): Promise<ScanResult> {
        try {
            console.log('Running OpenSCAP vulnerability scan...');
            
            const scapOutputDir = path.join(this.resultsDir, 'oscap');
            if (!fs.existsSync(scapOutputDir)) {
                fs.mkdirSync(scapOutputDir, { recursive: true });
            }
            
            const reportFile = path.join(scapOutputDir, `oscap-report-${Date.now()}.html`);
            const resultsFile = path.join(scapOutputDir, `oscap-results-${Date.now()}.xml`);
            
            // Determine appropriate SCAP content based on OS
            let scapContent = '';
            let profileId = '';
            
            const { stdout: osRelease } = await execAsync('cat /etc/os-release');
            
            if (osRelease.includes('rhel') || osRelease.includes('centos')) {
                scapContent = '/usr/share/xml/scap/ssg/content/ssg-rhel8-ds.xml';
                profileId = 'xccdf_org.ssgproject.content_profile_cis';
            } else if (osRelease.includes('ubuntu')) {
                scapContent = '/usr/share/xml/scap/ssg/content/ssg-ubuntu20.04-ds.xml';
                profileId = 'xccdf_org.ssgproject.content_profile_cis';
            } else if (osRelease.includes('debian')) {
                scapContent = '/usr/share/xml/scap/ssg/content/ssg-debian10-ds.xml';
                profileId = 'xccdf_org.ssgproject.content_profile_cis';
            } else {
                // Use generic OVAL definitions for CVEs
                scapContent = '/usr/share/xml/scap/oval/definitions/oval-definitions-5.xml';
            }
            
            // Check if the SCAP content exists
            if (!fs.existsSync(scapContent)) {
                console.log(`SCAP content not found at ${scapContent}. Using simulated results.`);
                return this.generateSimulatedScanResult('oscap');
            }
            
            // Run OpenSCAP scan
            await execAsync(`oscap xccdf eval --profile ${profileId} --results ${resultsFile} --report ${reportFile} ${scapContent}`);
            
            // Parse results XML
            const { stdout: xmlContent } = await execAsync(`cat ${resultsFile}`);
            
            // Parse XML to extract vulnerabilities (simplified)
            const vulnerabilities: Vulnerability[] = [];
            
            // Count failed rules as vulnerabilities
            const failedRules = xmlContent.match(/<result>fail<\/result>/g) || [];
            
            // Extract rule titles (simplified parsing, in real code you'd use proper XML parsing)
            const ruleTitles = xmlContent.match(/<title>(.*?)<\/title>/g) || [];
            
            // Create vulnerability entries
            for (let i = 0; i < failedRules.length; i++) {
                const titleMatch = i < ruleTitles.length ? ruleTitles[i].match(/<title>(.*?)<\/title>/) : null;
                const title = titleMatch ? titleMatch[1] : `Rule ${i + 1}`;
                
                // Determine severity (this is simplified)
                let severity: 'low' | 'medium' | 'high' | 'critical';
                if (title.toLowerCase().includes('critical')) {
                    severity = 'critical';
                } else if (title.toLowerCase().includes('high')) {
                    severity = 'high';
                } else if (title.toLowerCase().includes('medium')) {
                    severity = 'medium';
                } else {
                    severity = 'low';
                }
                
                vulnerabilities.push({
                    id: `OSCAP-${i + 1}`,
                    name: title,
                    severity,
                    description: `Failed compliance check: ${title}`,
                    remediation: 'Review OpenSCAP report for details',
                    discovered_at: new Date()
                });
            }
            
            // Count vulnerabilities by severity
            const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
            const high = vulnerabilities.filter(v => v.severity === 'high').length;
            const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
            const low = vulnerabilities.filter(v => v.severity === 'low').length;
            
            return {
                timestamp: new Date(),
                scanner: 'oscap',
                vulnerabilities,
                summary: {
                    total: vulnerabilities.length,
                    critical,
                    high,
                    medium,
                    low
                },
                scan_duration: 240, // Estimated
                scan_target: os.hostname(),
                scan_options: `${profileId} on ${scapContent}`
            };
        } catch (error) {
            console.error('Error running OpenSCAP scan:', error);
            throw error;
        }
    }

    /**
     * Run an APT security package scan (Debian/Ubuntu)
     */
    private async runAPTScan(): Promise<ScanResult> {
        try {
            console.log('Running APT security package scan...');
            
            // Update package lists
            await execAsync('apt update');
            
            // Get list of packages that can be upgraded
            const { stdout: upgradeablePackages } = await execAsync('apt list --upgradeable');
            
            // Check for security upgrades
            let securityPackages: string[];
            try {
                // Ubuntu-specific command
                const { stdout } = await execAsync('apt list --upgradeable -o APT::Get::Show-Versions=true | grep -i security');
                securityPackages = stdout.split('\n').filter(Boolean);
            } catch (error) {
                // If the grep fails (no security packages), we'll have an empty list
                securityPackages = [];
            }
            
            // Parse the package information
            const vulnerabilities: Vulnerability[] = [];
            
            securityPackages.forEach((packageLine, index) => {
                // Example line: libc6/bionic-updates,bionic-security 2.27-3ubuntu1.2 amd64 [upgradable from: 2.27-3ubuntu1]
                const match = packageLine.match(/([^ ]+)\/([^ ]+) ([^ ]+) ([^ ]+) \[upgradable from: ([^\]]+)\]/);
                
                if (match) {
                    const packageName = match[1];
                    const newVersion = match[3];
                    const oldVersion = match[5];
                    
                    // Assign severity based on package importance
                    let severity: 'low' | 'medium' | 'high' | 'critical';
                    
                    if (packageName.includes('linux-image') || 
                        packageName.includes('openssl') || 
                        packageName.includes('libc') || 
                        packageName.includes('sudo')) {
                        severity = 'critical';
                    } else if (packageName.includes('ssh') || 
                            packageName.includes('ssl') || 
                            packageName.includes('auth')) {
                        severity = 'high';
                    } else if (packageName.includes('apache') || 
                            packageName.includes('nginx') ||
                            packageName.includes('php')) {
                        severity = 'medium';
                    } else {
                        severity = 'low';
                    }
                    
                    vulnerabilities.push({
                        id: `APT-SEC-${index + 1}`,
                        name: `Security update available for ${packageName}`,
                        severity,
                        description: `Package ${packageName} has a security update available`,
                        affected_package: packageName,
                        affected_version: oldVersion,
                        fix_version: newVersion,
                        remediation: `Run 'apt upgrade ${packageName}' to update this package`,
                        discovered_at: new Date()
                    });
                }
            });
            
            // Count vulnerabilities by severity
            const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
            const high = vulnerabilities.filter(v => v.severity === 'high').length;
            const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
            const low = vulnerabilities.filter(v => v.severity === 'low').length;
            
            return {
                timestamp: new Date(),
                scanner: 'apt',
                vulnerabilities,
                summary: {
                    total: vulnerabilities.length,
                    critical,
                    high,
                    medium,
                    low
                },
                scan_duration: 60, // Estimated
                scan_target: os.hostname(),
                scan_options: 'APT security updates check'
            };
        } catch (error) {
            console.error('Error running APT security scan:', error);
            throw error;
        }
    }

    /**
     * Run a YUM security package scan (RHEL/CentOS/Fedora)
     */
    private async runYumScan(): Promise<ScanResult> {
        try {
            console.log('Running YUM security package scan...');
            
            // Try to use yum-security plugin if available
            let securityPackages: string[] = [];
            
            try {
                // Check if security plugin is available
                const { stdout: checkSecurity } = await execAsync('yum help security');
                
                if (checkSecurity.includes('security')) {
                    // Use yum security to check for security updates
                    const { stdout } = await execAsync('yum updateinfo list security');
                    securityPackages = stdout.split('\n').filter(line => 
                        line.includes('CVES') || 
                        line.includes('Security') || 
                        line.includes('Bugfix') || 
                        line.includes('Enhancement'));
                } else {
                    // Fallback to checking all updates
                    const { stdout } = await execAsync('yum check-update');
                    securityPackages = stdout.split('\n').filter(Boolean)
                        .filter(line => !line.startsWith('Loaded plugins') && !line.startsWith('Last metadata'));
                }
            } catch (error) {
                // If yum check-update finds updates, it exits with code 100
                if (error instanceof Error && 'stdout' in error) {
                    securityPackages = (error as any).stdout.split('\n').filter(Boolean)
                        .filter((line: string) => !line.startsWith('Loaded plugins') && !line.startsWith('Last metadata'));
                } else {
                    console.error('Error checking YUM updates:', error);
                }
            }
            
            // Parse the package information
            const vulnerabilities: Vulnerability[] = [];
            
            securityPackages.forEach((packageLine, index) => {
                // Try to extract package info (format varies based on YUM version and plugins)
                // This is a simplified parsing
                const parts = packageLine.split(/\s+/).filter(Boolean);
                
                if (parts.length >= 2) {
                    const packageName = parts[0];
                    const version = parts[1];
                    
                    // Look for CVE info in the line
                    const cveMatch = packageLine.match(/CVE-\d+-\d+/);
                    const cve = cveMatch ? cveMatch[0] : undefined;
                    
                    // Determine severity based on package type or CVE presence
                    let severity: 'low' | 'medium' | 'high' | 'critical';
                    
                    if (packageLine.includes('Critical')) {
                        severity = 'critical';
                    } else if (packageLine.includes('Important') || cve) {
                        severity = 'high';
                    } else if (packageLine.includes('Moderate')) {
                        severity = 'medium';
                    } else {
                        severity = 'low';
                    }
                    
                    vulnerabilities.push({
                        id: `YUM-SEC-${index + 1}`,
                        name: `Security update available for ${packageName}`,
                        severity,
                        description: `Package ${packageName} has a security update available`,
                        affected_package: packageName,
                        affected_version: 'Current version', // Would need more complex parsing to get current version
                        fix_version: version,
                        cve,
                        remediation: `Run 'yum update ${packageName}' to update this package`,
                        discovered_at: new Date()
                    });
                }
            });
            
            // Count vulnerabilities by severity
            const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
            const high = vulnerabilities.filter(v => v.severity === 'high').length;
            const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
            const low = vulnerabilities.filter(v => v.severity === 'low').length;
            
            return {
                timestamp: new Date(),
                scanner: 'yum',
                vulnerabilities,
                summary: {
                    total: vulnerabilities.length,
                    critical,
                    high,
                    medium,
                    low
                },
                scan_duration: 90, // Estimated
                scan_target: os.hostname(),
                scan_options: 'YUM security updates check'
            };
        } catch (error) {
            console.error('Error running YUM security scan:', error);
            throw error;
        }
    }

    /**
     * Run a Trivy container security scan
     */
    private async runTrivyScan(target: string = ''): Promise<ScanResult> {
        try {
            console.log('Running Trivy container security scan...');
            
            // Determine what to scan
            let scanTarget = target;
            
            if (!scanTarget) {
                // If no target specified, try to find containers to scan
                try {
                    const { stdout: dockerPs } = await execAsync('docker ps --format "{{.Image}}"');
                    const containerImages = dockerPs.split('\n').filter(Boolean);
                    
                    if (containerImages.length > 0) {
                        // Scan the first container image
                        scanTarget = containerImages[0];
                    } else {
                        // No running containers, check for all images
                        const { stdout: dockerImages } = await execAsync('docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "<none>"');
                        const images = dockerImages.split('\n').filter(Boolean);
                        
                        if (images.length > 0) {
                            scanTarget = images[0];
                        } else {
                            throw new Error('No Docker images found to scan');
                        }
                    }
                } catch (error) {
                    console.error('Error finding Docker images:', error);
                    throw new Error('No scan target specified and failed to find Docker images');
                }
            }
            
            // Create output directory if it doesn't exist
            const trivyOutputDir = path.join(this.resultsDir, 'trivy');
            if (!fs.existsSync(trivyOutputDir)) {
                fs.mkdirSync(trivyOutputDir, { recursive: true });
            }
            
            const jsonOutputFile = path.join(trivyOutputDir, `trivy-${Date.now()}.json`);
            
            // Run Trivy scan
            await execAsync(`trivy image --format json --output ${jsonOutputFile} ${scanTarget}`);
            
            // Parse JSON results
            const jsonContent = await fs.promises.readFile(jsonOutputFile, 'utf8');
            const results = JSON.parse(jsonContent);
            
            // Convert Trivy results to our vulnerability format
            const vulnerabilities: Vulnerability[] = [];
            
            // Process vulnerabilities from each result target
            if (Array.isArray(results.Results)) {
                results.Results.forEach((result: any) => {
                    if (Array.isArray(result.Vulnerabilities)) {
                        result.Vulnerabilities.forEach((vuln: any, index: number) => {
                            // Map Trivy severity to our format
                            let severity: 'low' | 'medium' | 'high' | 'critical';
                            switch (vuln.Severity?.toLowerCase()) {
                                case 'critical': severity = 'critical'; break;
                                case 'high': severity = 'high'; break;
                                case 'medium': severity = 'medium'; break;
                                default: severity = 'low';
                            }
                            
                            vulnerabilities.push({
                                id: vuln.VulnerabilityID || `TRIVY-${index + 1}`,
                                name: vuln.Title || `Vulnerability in ${vuln.PkgName}`,
                                severity,
                                description: vuln.Description || `Vulnerability in ${vuln.PkgName} version ${vuln.InstalledVersion}`,
                                affected_package: vuln.PkgName,
                                affected_version: vuln.InstalledVersion,
                                fix_version: vuln.FixedVersion,
                                cve: vuln.VulnerabilityID.startsWith('CVE-') ? vuln.VulnerabilityID : undefined,
                                remediation: vuln.FixedVersion ? `Update ${vuln.PkgName} to version ${vuln.FixedVersion}` : 'No fix available yet',
                                discovered_at: new Date()
                            });
                        });
                    }
                });
            }
            
            // Count vulnerabilities by severity
            const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
            const high = vulnerabilities.filter(v => v.severity === 'high').length;
            const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
            const low = vulnerabilities.filter(v => v.severity === 'low').length;
            
            return {
                timestamp: new Date(),
                scanner: 'trivy',
                vulnerabilities,
                summary: {
                    total: vulnerabilities.length,
                    critical,
                    high,
                    medium,
                    low
                },
                scan_duration: 120, // Estimated
                scan_target: scanTarget,
                scan_options: 'Container image scan'
            };
        } catch (error) {
            console.error('Error running Trivy scan:', error);
            throw error;
        }
    }

    /**
     * Generate simulated scan results for testing/demo purposes
     */
    private generateSimulatedScanResult(scannerType: string = 'simulated'): ScanResult {
        console.log('Generating simulated vulnerability scan results');
        
        // Generate a random number of vulnerabilities
        const vulnerabilityCount = Math.floor(Math.random() * 20) + 5; // 5-25 vulnerabilities
        
        const vulnerabilities = this.generateSimulatedVulnerabilities(vulnerabilityCount);
        
        // Count vulnerabilities by severity
        const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
        const high = vulnerabilities.filter(v => v.severity === 'high').length;
        const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
        const low = vulnerabilities.filter(v => v.severity === 'low').length;
        
        return {
            timestamp: new Date(),
            scanner: scannerType,
            vulnerabilities,
            summary: {
                total: vulnerabilities.length,
                critical,
                high,
                medium,
                low
            },
            scan_duration: Math.floor(Math.random() * 300) + 60, // 60-360 seconds
            scan_target: os.hostname(),
            scan_options: 'Simulated scan'
        };
    }

    /**
     * Generate simulated vulnerabilities for testing
     */
    private generateSimulatedVulnerabilities(count: number): Vulnerability[] {
        const vulnerabilities: Vulnerability[] = [];
        
        // Common package names for simulated vulnerabilities
        const packages = [
            'openssl', 'bash', 'apache2', 'nginx', 'mysql-server', 
            'php', 'nodejs', 'openssh-server', 'linux-kernel',
            'python', 'libxml2', 'glibc', 'sudo', 'imagemagick'
        ];
        
        // Common vulnerability types
        const vulnTypes = [
            'Buffer Overflow', 'SQL Injection', 'Cross-Site Scripting',
            'Remote Code Execution', 'Privilege Escalation', 'Information Disclosure',
            'Denial of Service', 'Memory Corruption', 'Integer Overflow'
        ];
        
        // Generate random vulnerabilities
        for (let i = 0; i < count; i++) {
            const packageName = packages[Math.floor(Math.random() * packages.length)];
            const vulnType = vulnTypes[Math.floor(Math.random() * vulnTypes.length)];
            
            // Randomly assign severity
            const severities: Array<'low' | 'medium' | 'high' | 'critical'> = ['low', 'medium', 'high', 'critical'];
            const severity = severities[Math.floor(Math.random() * severities.length)];
            
            // Generate a random CVE ID
            const year = 2020 + Math.floor(Math.random() * 5); // 2020-2024
            const cveNumber = Math.floor(Math.random() * 9000) + 1000; // 1000-9999
            const cve = `CVE-${year}-${cveNumber}`;
            
            // Generate affected and fixed versions
            const majorVersion = Math.floor(Math.random() * 5) + 1;
            const minorVersion = Math.floor(Math.random() * 10);
            const patchVersion = Math.floor(Math.random() * 20);
            const affectedVersion = `${majorVersion}.${minorVersion}.${patchVersion}`;
            const fixedVersion = `${majorVersion}.${minorVersion}.${patchVersion + 1}`;
            
            vulnerabilities.push({
                id: `SIM-${i + 1}`,
                name: `${vulnType} in ${packageName}`,
                severity,
                description: `A ${severity} severity ${vulnType.toLowerCase()} vulnerability in ${packageName} could allow an attacker to ${this.getRandomImpact(vulnType)}.`,
                affected_package: packageName,
                affected_version: affectedVersion,
                fix_version: fixedVersion,
                cve,
                remediation: `Update ${packageName} to version ${fixedVersion} or later`,
                discovered_at: new Date()
            });
        }
        
        return vulnerabilities;
    }

    /**
     * Get a random impact description for a vulnerability type
     */
    private getRandomImpact(vulnType: string): string {
        const impacts: { [key: string]: string[] } = {
            'Buffer Overflow': [
                'execute arbitrary code',
                'cause a denial of service',
                'crash the application'
            ],
            'SQL Injection': [
                'access unauthorized data',
                'modify database contents',
                'execute commands on the database server'
            ],
            'Cross-Site Scripting': [
                'steal user session data',
                'redirect users to malicious sites',
                'perform actions on behalf of the user'
            ],
            'Remote Code Execution': [
                'execute arbitrary commands on the system',
                'gain full control of the affected system',
                'install malware on the server'
            ],
            'Privilege Escalation': [
                'gain elevated system privileges',
                'access restricted system resources',
                'bypass security restrictions'
            ],
            'Information Disclosure': [
                'access sensitive data',
                'view configuration information',
                'obtain credentials or tokens'
            ],
            'Denial of Service': [
                'crash the service',
                'consume excessive system resources',
                'make the system unresponsive'
            ],
            'Memory Corruption': [
                'manipulate program memory',
                'cause unpredictable behavior',
                'potentially execute arbitrary code'
            ],
            'Integer Overflow': [
                'cause calculation errors',
                'bypass security checks',
                'potentially execute arbitrary code'
            ]
        };
        
        // Get possible impacts for this vulnerability type, or use default
        const possibleImpacts = impacts[vulnType] || [
            'compromise system security',
            'cause unexpected behavior',
            'affect system stability'
        ];
        
        return possibleImpacts[Math.floor(Math.random() * possibleImpacts.length)];
    }

    /**
     * Save scan result to a file
     */
    private async saveScanResult(result: ScanResult): Promise<void> {
        try {
            const timestamp = result.timestamp.toISOString().replace(/:/g, '-').replace(/\..+/, '');
            const fileName = `${result.scanner}-scan-${timestamp}.json`;
            const filePath = path.join(this.resultsDir, fileName);
            
            await fs.promises.writeFile(filePath, JSON.stringify(result, null, 2));
            console.log(`Scan result saved to ${filePath}`);
        } catch (error) {
            console.error('Error saving scan result:', error);
        }
    }

    /**
     * Report scan results to Discord
     */
    private async reportScanResults(result: ScanResult, scanType: 'manual' | 'scheduled'): Promise<void> {
        try {
            if (!this.client.isReady() || !this.notifyChannelId) return;
            
            const channel = await this.client.channels.fetch(this.notifyChannelId);
            if (!channel?.isTextBased()) return;
            
            // Determine color based on highest severity found
            let color = 0x00FF00; // Green (default - no issues)
            
            if (result.summary.critical > 0) {
                color = 0xFF0000; // Red
            } else if (result.summary.high > 0) {
                color = 0xFFA500; // Orange
            } else if (result.summary.medium > 0) {
                color = 0xFFFF00; // Yellow
            }
            
            // Create main summary embed
            const embed = new EmbedBuilder()
                .setTitle(`ðŸ” Vulnerability Scan Report (${result.scanner})`)
                .setDescription(`${scanType === 'manual' ? 'Manual' : 'Scheduled'} vulnerability scan completed on ${result.scan_target}`)
                .setColor(color)
                .setTimestamp(result.timestamp)
                .addFields(
                    { name: 'Scanner', value: result.scanner, inline: true },
                    { name: 'Duration', value: `${result.scan_duration} seconds`, inline: true },
                    { name: 'Target', value: result.scan_target, inline: true },
                    { name: 'Total Vulnerabilities', value: result.summary.total.toString(), inline: true },
                    { name: 'Critical', value: result.summary.critical.toString(), inline: true },
                    { name: 'High', value: result.summary.high.toString(), inline: true },
                    { name: 'Medium', value: result.summary.medium.toString(), inline: true },
                    { name: 'Low', value: result.summary.low.toString(), inline: true }
                );
            
            // Add summary of findings
            if (result.summary.total > 0) {
                // Add options if available
                if (result.scan_options) {
                    embed.addFields({ name: 'Scan Options', value: result.scan_options });
                }
                
                // Send main summary embed
                await (channel as TextChannel).send({ embeds: [embed] });
                
                // Create separate embeds for critical and high vulnerabilities
                // to avoid hitting Discord's field limits
                
                // Critical vulnerabilities
                const criticalVulns = result.vulnerabilities.filter(v => v.severity === 'critical');
                if (criticalVulns.length > 0) {
                    const criticalEmbed = new EmbedBuilder()
                        .setTitle('ðŸš¨ Critical Vulnerabilities')
                        .setDescription(`${criticalVulns.length} critical vulnerabilities found`)
                        .setColor(0xFF0000)
                        .setTimestamp();
                    
                    // Add fields for each critical vulnerability (limit to 25 for Discord limits)
                    criticalVulns.slice(0, 25).forEach(vuln => {
                        criticalEmbed.addFields({
                            name: `${vuln.id}: ${vuln.name}`,
                            value: `${vuln.description}\n${vuln.affected_package ? `Package: ${vuln.affected_package}` : ''}\n${vuln.cve ? `CVE: ${vuln.cve}` : ''}\nRemediation: ${vuln.remediation || 'Not available'}`
                        });
                    });
                    
                    if (criticalVulns.length > 25) {
                        criticalEmbed.addFields({
                            name: 'Additional Vulnerabilities',
                            value: `${criticalVulns.length - 25} more critical vulnerabilities not shown`
                        });
                    }
                    
                    await (channel as TextChannel).send({ embeds: [criticalEmbed] });
                }
                
                // High vulnerabilities
                const highVulns = result.vulnerabilities.filter(v => v.severity === 'high');
                if (highVulns.length > 0) {
                    const highEmbed = new EmbedBuilder()
                        .setTitle('âš ï¸ High Severity Vulnerabilities')
                        .setDescription(`${highVulns.length} high severity vulnerabilities found`)
                        .setColor(0xFFA500)
                        .setTimestamp();
                    
                    // Add fields for each high vulnerability (limit to 25 for Discord limits)
                    highVulns.slice(0, 25).forEach(vuln => {
                        highEmbed.addFields({
                            name: `${vuln.id}: ${vuln.name}`,
                            value: `${vuln.affected_package ? `Package: ${vuln.affected_package}` : ''}\n${vuln.cve ? `CVE: ${vuln.cve}` : ''}\nRemediation: ${vuln.remediation || 'Not available'}`
                        });
                    });
                    
                    if (highVulns.length > 25) {
                        highEmbed.addFields({
                            name: 'Additional Vulnerabilities',
                            value: `${highVulns.length - 25} more high severity vulnerabilities not shown`
                        });
                    }
                    
                    await (channel as TextChannel).send({ embeds: [highEmbed] });
                }
                
                // Summary of medium and low vulnerabilities
                const otherVulns = result.vulnerabilities.filter(v => v.severity === 'medium' || v.severity === 'low');
                if (otherVulns.length > 0) {
                    // Group by type/package
                    const vulnsByPackage: { [key: string]: { count: number, severity: { medium: number, low: number } } } = {};
                    
                    otherVulns.forEach(vuln => {
                        const key = vuln.affected_package || vuln.name.split(' ')[0];
                        if (!vulnsByPackage[key]) {
                            vulnsByPackage[key] = { count: 0, severity: { medium: 0, low: 0 } };
                        }
                        vulnsByPackage[key].count++;
                        vuln.severity === 'medium' ? vulnsByPackage[key].severity.medium++ : vulnsByPackage[key].severity.low++;
                    });
                    
                    const summaryEmbed = new EmbedBuilder()
                        .setTitle('ðŸ“Š Medium and Low Severity Summary')
                        .setDescription(`${otherVulns.length} medium and low severity vulnerabilities found`)
                        .setColor(0xFFFF00)
                        .setTimestamp();
                    
                    // Add a summary field for each package/group
                    Object.entries(vulnsByPackage).forEach(([key, data]) => {
                        summaryEmbed.addFields({
                            name: key,
                            value: `${data.count} vulnerabilities (${data.severity.medium} medium, ${data.severity.low} low)`,
                            inline: true
                        });
                    });
                    
                    await (channel as TextChannel).send({ embeds: [summaryEmbed] });
                }
            } else {
                // No vulnerabilities found
                embed.setDescription(`${scanType === 'manual' ? 'Manual' : 'Scheduled'} vulnerability scan completed on ${result.scan_target}\n\nâœ… No vulnerabilities found!`);
                await (channel as TextChannel).send({ embeds: [embed] });
            }
            
        } catch (error) {
            console.error('Error reporting scan results to Discord:', error);
        }
    }

    /**
     * Get the most recent scan result
     */
    public getLastScanResult(): ScanResult | null {
        return this.lastScanResult;
    }

    /**
     * Get all previous scan results (summaries only)
     */
    public async getPreviousScanResults(limit: number = 10): Promise<{ timestamp: Date, scanner: string, summary: { total: number, critical: number, high: number, medium: number, low: number } }[]> {
        try {
            // Read scan result files from results directory
            const files = await fs.promises.readdir(this.resultsDir);
            
            // Filter JSON files and sort by modification time (newest first)
            const jsonFiles = files.filter(file => file.endsWith('.json'));
            
            const fileStats = await Promise.all(
                jsonFiles.map(async file => {
                    const filePath = path.join(this.resultsDir, file);
                    const stats = await fs.promises.stat(filePath);
                    return { file, stats };
                })
            );
            
            fileStats.sort((a, b) => b.stats.mtime.getTime() - a.stats.mtime.getTime());
            
            // Read the most recent files up to the limit
            const results = await Promise.all(
                fileStats.slice(0, limit).map(async ({ file }) => {
                    const filePath = path.join(this.resultsDir, file);
                    const content = await fs.promises.readFile(filePath, 'utf8');
                    const scanResult = JSON.parse(content);
                    
                    return {
                        timestamp: new Date(scanResult.timestamp),
                        scanner: scanResult.scanner,
                        summary: scanResult.summary
                    };
                })
            );
            
            return results;
        } catch (error) {
            console.error('Error getting previous scan results:', error);
            return [];
        }
    }

    /**
     * Get a trend analysis of vulnerabilities over time
     */
    public async getVulnerabilityTrend(): Promise<{ 
        dates: string[], 
        critical: number[], 
        high: number[], 
        medium: number[], 
        low: number[]
    }> {
        try {
            // Get all previous scan results
            const allResults = await this.getPreviousScanResults(100);
            
            // Group by date (YYYY-MM-DD)
            const resultsByDate: { [key: string]: { critical: number, high: number, medium: number, low: number }[] } = {};
            
            allResults.forEach(result => {
                const dateString = result.timestamp.toISOString().split('T')[0];
                
                if (!resultsByDate[dateString]) {
                    resultsByDate[dateString] = [];
                }
                
                resultsByDate[dateString].push({
                    critical: result.summary.critical,
                    high: result.summary.high,
                    medium: result.summary.medium,
                    low: result.summary.low
                });
            });
            
            // Calculate average for each date if multiple scans exist
            const trend: { 
                dates: string[], 
                critical: number[], 
                high: number[], 
                medium: number[], 
                low: number[] 
            } = {
                dates: [],
                critical: [],
                high: [],
                medium: [],
                low: []
            };
            
            // Sort dates
            const sortedDates = Object.keys(resultsByDate).sort();
            
            sortedDates.forEach(date => {
                const results = resultsByDate[date];
                
                // Calculate average values for this date
                const avgCritical = Math.round(results.reduce((sum, r) => sum + r.critical, 0) / results.length);
                const avgHigh = Math.round(results.reduce((sum, r) => sum + r.high, 0) / results.length);
                const avgMedium = Math.round(results.reduce((sum, r) => sum + r.medium, 0) / results.length);
                const avgLow = Math.round(results.reduce((sum, r) => sum + r.low, 0) / results.length);
                
                trend.dates.push(date);
                trend.critical.push(avgCritical);
                trend.high.push(avgHigh);
                trend.medium.push(avgMedium);
                trend.low.push(avgLow);
            });
            
            return trend;
        } catch (error) {
            console.error('Error getting vulnerability trend:', error);
            return { dates: [], critical: [], high: [], medium: [], low: [] };
        }
    }
}

// Export singleton instance
let vulnerabilityScannerInstance: VulnerabilityScanner | null = null;

export function getVulnerabilityScanner(
    client: Client,
    notifyChannelId: string,
    logEvent: (type: string, description: string) => Promise<boolean>,
    resultsDir?: string
): VulnerabilityScanner {
    if (!vulnerabilityScannerInstance) {
        vulnerabilityScannerInstance = new VulnerabilityScanner(
            client,
            notifyChannelId,
            logEvent,
            resultsDir
        );
    }
    return vulnerabilityScannerInstance;
}
